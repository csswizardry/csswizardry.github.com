<!DOCTYPE html>
<html lang=en-GB class="page  {{ page.page-class }}  {{ layout.page-class }}" id=htmlElement>

  {% include head.html %}

  <nav class=hide>
    <a href="
             {% if page.page-class == 'page--home' %}
              #section:articles
             {% else %}
              #section:main
             {% endif %}
            ">Skip to main content</a>
  </nav>

  {{ content }}

  <script>
    performance.measure('contentTime', {
      start: 'contentStart',
      end: 'contentEnd',
      detail: {
        devtools: {
          dataType: 'track-entry',
          trackGroup: 'csswizardry.com',
          track: 'Technical Timings',
          tooltipText: 'Main Content Parsed',
          color: 'secondary-light'
        }
      }
    });
  </script>

  <style>

    /**
     * The site nav has been explicitly ‘turned off’ with `content-visibility:
     * hidden;` in its component (S)CSS file. This means we don’t need to bother
     * rendering it at all on the first pass: it’s off-screen anyway. Once we’re
     * approaching `domInteractive` (that’s now), we turn it ‘back on’. This
     * prioritises the painting of on-screen or above-the-fold content ahead of
     * an off-screen nav drawer.
     */

    .site-nav__list {
      content-visibility: visible;
    }

    /*# sourceURL=nav-visibility.inline.css */

  </style>

  <script type=speculationrules>
    {
      "prefetch": [
        {
          "where": {
            "href_matches": "/*"
          },
          "eagerness": "immediate"
        }
      ],
      "prerender": [
        {
          "where": {
            "href_matches": "/*"
          },
          "eagerness": "moderate"
        }
      ]
    }
  </script>

  <script>
    (() => {
      if ('connection.rtt' in navigator) {
        const rtt = navigator.connection.rtt;
        LUX.addData('rtt', rtt);
      }
    })();
  </script>

  <script>
    if ('serviceWorker' in navigator) {

      navigator.serviceWorker.getRegistrations()
        .then(registrations => {
          return Promise.all(
            registrations.map(reg => reg.unregister())
          );
        })

        .then(() => caches.keys())
        .then(names => {
          return Promise.all(
            names.map(name => caches.delete(name))
          );
        })

    }

    //# sourceURL=sw.inline.js
  </script>

  <script src=/js/obs.speedcurve.js?v=0001 type=module></script>
